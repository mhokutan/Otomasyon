name: yt-auto-story

on:
  workflow_dispatch:
  schedule:
    - cron: "0 */8 * * *"  # UTC; gÃ¼nde 3 kez

jobs:
  publish-story:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    strategy:
      fail-fast: false
      matrix:
        include:
          - lang: en
            region: US
            title_prefix: "Mystery Story:"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Install system deps (ffmpeg & fonts)
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg fonts-dejavu-core

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install google-api-python-client google-auth google-auth-oauthlib

      - name: Preflight (keys)
        id: gates
        env:
          YT_CLIENT_ID: ${{ secrets.YT_CLIENT_ID }}
          YT_CLIENT_SECRET: ${{ secrets.YT_CLIENT_SECRET }}
          YT_REFRESH_TOKEN: ${{ secrets.YT_REFRESH_TOKEN }}
        run: |
          set -euo pipefail
          has_yt=false
          if [ -n "${YT_CLIENT_ID:-}" ] && [ -n "${YT_CLIENT_SECRET:-}" ] && [ -n "${YT_REFRESH_TOKEN:-}" ]; then
            has_yt=true
          else
            echo "::warning::YouTube secret'larÄ±ndan biri eksik; upload atlanacak"
          fi
          echo "has_yt=$has_yt" >> "$GITHUB_OUTPUT"

      - name: Build video (STORY â€¢ ${{ matrix.lang }})
        id: build
        env:
          THEME: "story"
          LANGUAGE: ${{ matrix.lang }}
          REGION: ${{ matrix.region }}
          VIDEO_TITLE_PREFIX: ${{ matrix.title_prefix }}

          # (Opsiyonel) Seriyi tek dil hattÄ±na sabitle:
          SERIES_LANG_KEY: "en"
          SERIES_NAME: "Mystery Files"
          SERIES_SEASON: "1"

          # ðŸ”Š OpenAI
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY != '' && secrets.OPENAI_API_KEY || vars.OPENAI_API_KEY }}
          OPENAI_BASE_URL: ${{ vars.OPENAI_BASE_URL != '' && vars.OPENAI_BASE_URL || 'https://api.openai.com/v1' }}
          OPENAI_MODEL_CHAT: ${{ vars.OPENAI_MODEL_CHAT != '' && vars.OPENAI_MODEL_CHAT || 'gpt-4o-mini' }}
          OPENAI_MODEL_TTS:  ${{ vars.OPENAI_MODEL_TTS  != '' && vars.OPENAI_MODEL_TTS  || 'gpt-4o-mini-tts' }}
          OPENAI_MAX_TOKENS: ${{ vars.OPENAI_MAX_TOKENS != '' && vars.OPENAI_MAX_TOKENS || '400' }}
          OPENAI_TEMPERATURE: ${{ vars.OPENAI_TEMPERATURE != '' && vars.OPENAI_TEMPERATURE || '0.7' }}

          # TTS
          TTS_VOICE: ${{ vars.TTS_VOICE != '' && vars.TTS_VOICE || 'alloy' }}
          TTS_ATEMPO: ${{ vars.TTS_ATEMPO != '' && vars.TTS_ATEMPO || '1.07' }}
          TTS_BITRATE: ${{ vars.TTS_BITRATE != '' && vars.TTS_BITRATE || '128k' }}

          # Video
          BG_IMAGES_PER_SLIDE: ${{ vars.BG_IMAGES_PER_SLIDE != '' && vars.BG_IMAGES_PER_SLIDE || '4' }}
          FPS: ${{ vars.FPS != '' && vars.FPS || '60' }}
          CRF: ${{ vars.CRF != '' && vars.CRF || '22' }}
          ALLOW_NET_BG: ${{ vars.ALLOW_NET_BG != '' && vars.ALLOW_NET_BG || '0' }}
          NET_TIMEOUT: ${{ vars.NET_TIMEOUT != '' && vars.NET_TIMEOUT || '20' }}
          MAX_BG_SIZE_MB: ${{ vars.MAX_BG_SIZE_MB != '' && vars.MAX_BG_SIZE_MB || '8' }}

          # Presenter/overlay
          BREAKING_ON: ${{ vars.BREAKING_ON != '' && vars.BREAKING_ON || '0' }}
          BREAKING_TEXT: ${{ vars.BREAKING_TEXT != '' && vars.BREAKING_TEXT || 'BREAKING' }}
          PRESENTER_URL: ${{ vars.PRESENTER_URL }}
          PRESENTER_POS: ${{ vars.PRESENTER_POS != '' && vars.PRESENTER_POS || 'top-right' }}
          PRESENTER_SIZE: ${{ vars.PRESENTER_SIZE != '' && vars.PRESENTER_SIZE || '260' }}
          PRESENTER_INITIALS: ${{ vars.PRESENTER_INITIALS != '' && vars.PRESENTER_INITIALS || 'AI' }}

          HF_TOKEN: ${{ secrets.HF_TOKEN != '' && secrets.HF_TOKEN || vars.HF_TOKEN }}

          PYTHONIOENCODING: "utf-8"
          LANG: "en_US.UTF-8"
          PYTHONFAULTHANDLER: "1"
        run: |
          set -euo pipefail
          mkdir -p out
          echo "== RUN =="
          python -X dev -u -m src.main 2>&1 | tee "out/run_${{ matrix.lang }}.log" || true
          echo "== OUT =="
          ls -lah out || true

          latest="$(ls -t out/*.mp4 2>/dev/null | head -n1 || true)"
          if [ -z "$latest" ]; then
            echo "::error::HiÃ§ .mp4 Ã¼retilmemiÅŸ gÃ¶rÃ¼nÃ¼yor (out/*.mp4 bulunamadÄ±)"; exit 1
          fi

          echo "SeÃ§ilen video: $latest"
          # ðŸŽ§ Ses akÄ±ÅŸÄ± kontrolÃ¼
          if ! ffprobe -v error -select_streams a -show_entries stream=codec_name -of csv=p=0 "$latest" | grep -q .; then
            echo "::error::Videoda audio stream yok. TTS baÅŸarÄ±sÄ±z olmuÅŸ olabilir. out/run_${{ matrix.lang }}.log dosyasÄ±nÄ± kontrol edin."
            exit 1
          fi

          echo "video_path=$latest" >> "$GITHUB_OUTPUT"

      # ðŸ”Ž SEO meta'yÄ± (out/seo_meta.json) oku ve Ã§Ä±ktÄ±larÄ± ayarla
      - name: Read SEO metadata
        id: seo
        run: |
          set -euo pipefail
          if [ ! -f out/seo_meta.json ]; then
            echo "::warning::out/seo_meta.json yok; fallback baÅŸlÄ±k/aÃ§Ä±klama kullanÄ±lacak"
            echo "title=" >> "$GITHUB_OUTPUT"
            echo "description=" >> "$GITHUB_OUTPUT"
            echo "tags_csv=" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          python - << 'PY'
          import os, json
          meta = json.load(open("out/seo_meta.json", encoding="utf-8"))
          title = meta.get("title","")
          desc  = meta.get("description","")
          tags  = meta.get("tags","")
          if isinstance(tags, list):
              tags = ",".join(t for t in tags if t and isinstance(t,str))
          go = os.environ["GITHUB_OUTPUT"]
          with open(go, "a", encoding="utf-8") as f:
              f.write("title<<EOX\n"+(title or "")+"\nEOX\n")
              f.write("description<<EOY\n"+(desc or "")+"\nEOY\n")
              f.write("tags_csv="+(tags or "")+"\n")
          PY

      - name: Auth smoke test (YouTube)
        if: ${{ steps.gates.outputs.has_yt == 'true' }}
        env:
          YT_CLIENT_ID: ${{ secrets.YT_CLIENT_ID }}
          YT_CLIENT_SECRET: ${{ secrets.YT_CLIENT_SECRET }}
          YT_REFRESH_TOKEN: ${{ secrets.YT_REFRESH_TOKEN }}
        run: |
          python - << 'PY'
          import os
          import google.auth.transport.requests
          from google.oauth2.credentials import Credentials
          creds = Credentials(
              None,
              refresh_token=os.environ["YT_REFRESH_TOKEN"],
              client_id=os.environ["YT_CLIENT_ID"],
              client_secret=os.environ["YT_CLIENT_SECRET"],
              token_uri="https://oauth2.googleapis.com/token",
          )
          creds.refresh(google.auth.transport.requests.Request())
          print("Refresh OK")
          PY

      - name: Upload to YouTube (${{ matrix.lang }})
        if: ${{ steps.gates.outputs.has_yt == 'true' }}
        env:
          VIDEO_PATH: ${{ steps.build.outputs.video_path }}

          # SEO Ã§Ä±ktÄ±lar
          SEO_TITLE: ${{ steps.seo.outputs.title }}
          SEO_DESC: ${{ steps.seo.outputs.description }}
          SEO_TAGS_CSV: ${{ steps.seo.outputs.tags_csv }}

          # Fallback'ler
          FALLBACK_TITLE: ${{ matrix.title_prefix }} Daily Auto Story
          FALLBACK_DESC: Lang=${{ matrix.lang }}, Region=${{ matrix.region }} â€¢ Otomasyon yÃ¼klemesi

          YT_PRIVACY: "public"
          YT_MADE_FOR_KIDS: "false"
          YT_CLIENT_ID: ${{ secrets.YT_CLIENT_ID }}
          YT_CLIENT_SECRET: ${{ secrets.YT_CLIENT_SECRET }}
          YT_REFRESH_TOKEN: ${{ secrets.YT_REFRESH_TOKEN }}
          YT_DEBUG: "1"
        run: |
          set -euo pipefail
          TITLE="${SEO_TITLE:-$FALLBACK_TITLE}"
          DESC="${SEO_DESC:-$FALLBACK_DESC}"
          TAGS="${SEO_TAGS_CSV:-shorts,story,ai}"

          echo "YÃ¼klenecek dosya: $VIDEO_PATH"
          echo "BaÅŸlÄ±k: $TITLE"
          echo "AÃ§Ä±klama(ilk 160): ${DESC:0:160}..."
          echo "Etiketler: $TAGS"

          python - << 'PY'
          from __future__ import annotations
          import os, json, mimetypes, pathlib, time
          from typing import Any
          from googleapiclient.discovery import build
          from googleapiclient.http import MediaFileUpload
          from google.auth.transport.requests import Request
          from google.oauth2.credentials import Credentials

          def dump_json(path: str, obj: Any) -> None:
              os.makedirs("out", exist_ok=True)
              with open(path, "w", encoding="utf-8") as f:
                  json.dump(obj, f, ensure_ascii=False, indent=2)

          def creds() -> Credentials:
              cid = os.environ["YT_CLIENT_ID"]; csec = os.environ["YT_CLIENT_SECRET"]; rtok = os.environ["YT_REFRESH_TOKEN"]
              c = Credentials(None, refresh_token=rtok, client_id=cid, client_secret=csec, token_uri="https://oauth2.googleapis.com/token")
              c.refresh(Request())
              return c

          vp = pathlib.Path(os.environ["VIDEO_PATH"])
          if not vp.exists() or vp.stat().st_size <= 0:
              raise RuntimeError(f"Video yok/boÅŸ: {vp}")

          title = os.environ.get("TITLE","Auto Story")[:95]
          desc  = os.environ.get("DESC","")[:4900]
          tags  = [t.strip() for t in os.environ.get("TAGS","").split(",") if t.strip()]

          yt = build("youtube","v3",credentials=creds(), cache_discovery=False)
          body = {
            "snippet": {
              "title": title,
              "description": desc,
              "categoryId": "22",
              **({"tags": tags} if tags else {})
            },
            "status": {
              "privacyStatus": os.environ.get("YT_PRIVACY","public"),
              "selfDeclaredMadeForKids": os.environ.get("YT_MADE_FOR_KIDS","false").lower() in ("1","true","yes","on")
            }
          }

          mime,_ = mimetypes.guess_type(str(vp))
          media = MediaFileUpload(str(vp), mimetype=mime or "video/mp4", chunksize=1024*1024, resumable=True)
          req = yt.videos().insert(part="snippet,status", body=body, media_body=media)

          resp=None; last=-1; start=time.monotonic()
          while resp is None:
              status, resp = req.next_chunk()
              if status and hasattr(status,"progress"):
                  try:
                      pct = int(float(status.progress())*100)
                      if pct != last:
                          print(f"[upload] {pct}%"); last = pct
                  except: pass
              if time.monotonic()-start > 1800:
                  raise RuntimeError("Upload timed out (1800s)")
          dump_json("out/youtube_response.json", resp or {})
          vid = (resp or {}).get("id")
          print("[done] https://youtu.be/"+vid if vid else "[done] (id yok)")
          PY
        env:
          TITLE: ${{ env.TITLE || '' }}
          DESC: ${{ env.DESC || '' }}
          TAGS: ${{ env.TAGS || '' }}

      - name: Upload artifact (${{ matrix.lang }})
        uses: actions/upload-artifact@v4
        with:
          name: output-story-${{ matrix.lang }}
          path: out/**
          if-no-files-found: warn
          retention-days: 7

name: yt-auto-story

on:
  workflow_dispatch:
  schedule:
    - cron: "0 */8 * * *" # UTC; günde 3 kez

jobs:
  publish-story:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    strategy:
      fail-fast: false
      matrix:
        include:
          - lang: en
            region: US
            title_prefix: "Mystery Story:"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Install system deps (ffmpeg & fonts)
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg fonts-dejavu-core

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install google-api-python-client google-auth google-auth-oauthlib

      - name: Preflight (keys)
        id: gates
        env:
          YT_CLIENT_ID: ${{ secrets.YT_CLIENT_ID }}
          YT_CLIENT_SECRET: ${{ secrets.YT_CLIENT_SECRET }}
          YT_REFRESH_TOKEN: ${{ secrets.YT_REFRESH_TOKEN }}
        run: |
          set -euo pipefail
          has_yt=false
          if [ -n "${YT_CLIENT_ID:-}" ] && [ -n "${YT_CLIENT_SECRET:-}" ] && [ -n "${YT_REFRESH_TOKEN:-}" ]; then
            has_yt=true
          else
            echo "::warning::YouTube secret'larından biri eksik; upload atlanacak"
          fi
          echo "has_yt=$has_yt" >> "$GITHUB_OUTPUT"

      - name: Build video (STORY • ${{ matrix.lang }})
        id: build
        env:
          THEME: "story"
          LANGUAGE: ${{ matrix.lang }}
          REGION: ${{ matrix.region }}
          VIDEO_TITLE_PREFIX: ${{ matrix.title_prefix }}

          # Seriyi tek hat üzerinden takip etmek istersen:
          SERIES_LANG_KEY: "en"
          SERIES_NAME: "Mystery Files"
          SERIES_SEASON: "1"

          # OpenAI
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY != '' && secrets.OPENAI_API_KEY || vars.OPENAI_API_KEY }}
          OPENAI_BASE_URL: ${{ vars.OPENAI_BASE_URL != '' && vars.OPENAI_BASE_URL || 'https://api.openai.com/v1' }}
          OPENAI_MODEL_CHAT: ${{ vars.OPENAI_MODEL_CHAT != '' && vars.OPENAI_MODEL_CHAT || 'gpt-4o-mini' }}
          OPENAI_MODEL_TTS:  ${{ vars.OPENAI_MODEL_TTS  != '' && vars.OPENAI_MODEL_TTS  || 'gpt-4o-mini-tts' }}
          OPENAI_MAX_TOKENS: ${{ vars.OPENAI_MAX_TOKENS != '' && vars.OPENAI_MAX_TOKENS || '400' }}
          OPENAI_TEMPERATURE: ${{ vars.OPENAI_TEMPERATURE != '' && vars.OPENAI_TEMPERATURE || '0.7' }}

          # TTS
          TTS_VOICE: ${{ vars.TTS_VOICE != '' && vars.TTS_VOICE || 'alloy' }}
          TTS_ATEMPO: ${{ vars.TTS_ATEMPO != '' && vars.TTS_ATEMPO || '1.07' }}
          TTS_BITRATE: ${{ vars.TTS_BITRATE != '' && vars.TTS_BITRATE || '128k' }}

          # Video
          BG_IMAGES_PER_SLIDE: ${{ vars.BG_IMAGES_PER_SLIDE != '' && vars.BG_IMAGES_PER_SLIDE || '4' }}
          FPS: ${{ vars.FPS != '' && vars.FPS || '60' }}
          CRF: ${{ vars.CRF != '' && vars.CRF || '22' }}
          ALLOW_NET_BG: ${{ vars.ALLOW_NET_BG != '' && vars.ALLOW_NET_BG || '0' }}
          NET_TIMEOUT: ${{ vars.NET_TIMEOUT != '' && vars.NET_TIMEOUT || '20' }}
          MAX_BG_SIZE_MB: ${{ vars.MAX_BG_SIZE_MB != '' && vars.MAX_BG_SIZE_MB || '8' }}

          # Presenter/overlay
          BREAKING_ON: ${{ vars.BREAKING_ON != '' && vars.BREAKING_ON || '0' }}
          BREAKING_TEXT: ${{ vars.BREAKING_TEXT != '' && vars.BREAKING_TEXT || 'BREAKING' }}
          PRESENTER_URL: ${{ vars.PRESENTER_URL }}
          PRESENTER_POS: ${{ vars.PRESENTER_POS != '' && vars.PRESENTER_POS || 'top-right' }}
          PRESENTER_SIZE: ${{ vars.PRESENTER_SIZE != '' && vars.PRESENTER_SIZE || '260' }}
          PRESENTER_INITIALS: ${{ vars.PRESENTER_INITIALS != '' && vars.PRESENTER_INITIALS || 'AI' }}

          HF_TOKEN: ${{ secrets.HF_TOKEN != '' && secrets.HF_TOKEN || vars.HF_TOKEN }}

          PYTHONIOENCODING: "utf-8"
          LANG: "en_US.UTF-8"
          PYTHONFAULTHANDLER: "1"
        run: |
          set -euo pipefail
          mkdir -p out
          echo "== RUN =="
          python -X dev -u -m src.main 2>&1 | tee "out/run_${{ matrix.lang }}.log" || true
          echo "== OUT =="
          ls -lah out || true

          latest="$(ls -t out/*.mp4 2>/dev/null | head -n1 || true)"
          if [ -z "$latest" ]; then
            echo "::error::Hiç .mp4 üretilmemiş görünüyor (out/*.mp4 bulunamadı)"; exit 1
          fi

          echo "Seçilen video: $latest"
          # Ses var mı?
          if ! ffprobe -v error -select_streams a -show_entries stream=codec_name -of csv=p=0 "$latest" | grep -q .; then
            echo "::error::Videoda audio stream yok. TTS başarısız olmuş olabilir. out/run_${{ matrix.lang }}.log dosyasını kontrol edin."
            exit 1
          fi

          echo "video_path=$latest" >> "$GITHUB_OUTPUT"

      - name: Read SEO metadata (from out/seo_meta.json)
        id: seo
        env:
          FALLBACK_TITLE: ${{ matrix.title_prefix }} Daily Auto Story
          FALLBACK_DESC: Lang=${{ matrix.lang }}, Region=${{ matrix.region }} • Auto upload
        run: |
          set -euo pipefail
          python - << 'PY'
          import os, json, pathlib, sys
          p = pathlib.Path("out/seo_meta.json")
          title = os.environ.get("FALLBACK_TITLE","Auto Story")
          desc  = os.environ.get("FALLBACK_DESC","")
          tags  = "shorts,story,ai"
          if p.exists():
              try:
                  d = json.loads(p.read_text(encoding="utf-8"))
                  title = d.get("title") or title
                  desc  = d.get("description") or desc
                  tags  = d.get("tags") or tags
              except Exception as e:
                  print(f"::warning::seo_meta.json parse failed: {e}")
          go = os.environ["GITHUB_OUTPUT"]
          with open(go, "a", encoding="utf-8") as f:
              f.write(f"title<<EOF\n{title}\nEOF\n")
              f.write(f"description<<EOF\n{desc}\nEOF\n")
              f.write(f"tags_csv={tags}\n")
          PY

      - name: Auth smoke test (YouTube)
        if: ${{ steps.gates.outputs.has_yt == 'true' }}
        env:
          YT_CLIENT_ID: ${{ secrets.YT_CLIENT_ID }}
          YT_CLIENT_SECRET: ${{ secrets.YT_CLIENT_SECRET }}
          YT_REFRESH_TOKEN: ${{ secrets.YT_REFRESH_TOKEN }}
        run: |
          python - << 'PY'
          import os
          import google.auth.transport.requests
          from google.oauth2.credentials import Credentials
          creds = Credentials(
              None,
              refresh_token=os.environ["YT_REFRESH_TOKEN"],
              client_id=os.environ["YT_CLIENT_ID"],
              client_secret=os.environ["YT_CLIENT_SECRET"],
              token_uri="https://oauth2.googleapis.com/token",
          )
          creds.refresh(google.auth.transport.requests.Request())
          print("Refresh OK")
          PY

      - name: Upload to YouTube (${{ matrix.lang }})
        if: ${{ steps.gates.outputs.has_yt == 'true' }}
        env:
          VIDEO_PATH: ${{ steps.build.outputs.video_path }}

          # SEO çıktılar
          SEO_TITLE: ${{ steps.seo.outputs.title }}
          SEO_DESC: ${{ steps.seo.outputs.description }}
          SEO_TAGS_CSV: ${{ steps.seo.outputs.tags_csv }}

          # Fallback
          FALLBACK_TITLE: ${{ matrix.title_prefix }} Daily Auto Story
          FALLBACK_DESC: Lang=${{ matrix.lang }}, Region=${{ matrix.region }} • Auto upload

          # YouTube creds
          YT_PRIVACY: "public"
          YT_MADE_FOR_KIDS: "false"
          YT_CLIENT_ID: ${{ secrets.YT_CLIENT_ID }}
          YT_CLIENT_SECRET: ${{ secrets.YT_CLIENT_SECRET }}
          YT_REFRESH_TOKEN: ${{ secrets.YT_REFRESH_TOKEN }}
          YT_DEBUG: "1"
        run: |
          set -euo pipefail
          TITLE="${SEO_TITLE:-$FALLBACK_TITLE}"
          DESC="${SEO_DESC:-$FALLBACK_DESC}"
          TAGS="${SEO_TAGS_CSV:-shorts,story,ai}"

          echo "Yüklenecek dosya: $VIDEO_PATH"
          echo "Başlık: $TITLE"
          echo "Açıklama (ilk 160): ${DESC:0:160}..."
          echo "Etiketler: $TAGS"

          python - << 'PY'
          from __future__ import annotations
          import os, json, mimetypes, pathlib, time
          from typing import Any
          from googleapiclient.discovery import build
          from googleapiclient.http import MediaFileUpload
          from google.auth.transport.requests import Request
          from google.oauth2.credentials import Credentials

          def dump_json(path: str, obj: Any) -> None:
              os.makedirs("out", exist_ok=True)
              with open(path, "w", encoding="utf-8") as f:
                  json.dump(obj, f, ensure_ascii=False, indent=2)

          def creds() -> Credentials:
              c = Credentials(
                  None,
                  refresh_token=os.environ["YT_REFRESH_TOKEN"],
                  client_id=os.environ["YT_CLIENT_ID"],
                  client_secret=os.environ["YT_CLIENT_SECRET"],
                  token_uri="https://oauth2.googleapis.com/token",
              )
              c.refresh(Request())
              return c

          vp = pathlib.Path(os.environ["VIDEO_PATH"])
          if not vp.exists() or vp.stat().st_size <= 0:
              raise SystemExit("Video bulunamadı/boş: " + str(vp))

          tags = [t.strip() for t in os.environ.get("TAGS", os.environ.get("TAGS", "")).split(",") if t.strip()]
          if not tags:
              tags = [t.strip() for t in os.environ.get("SEO_TAGS_CSV","").split(",") if t.strip()]

          yt = build("youtube", "v3", credentials=creds(), cache_discovery=False)
          body = {
              "snippet": {
                  "title": os.environ.get("TITLE","Auto Story")[:95],
                  "description": os.environ.get("DESC","")[:4900],
                  "categoryId": "22",
                  **({"tags": tags} if tags else {})
              },
              "status": {
                  "privacyStatus": os.environ.get("YT_PRIVACY","public"),
                  "selfDeclaredMadeForKids": os.environ.get("YT_MADE_FOR_KIDS","false").lower() in ("1","true","yes","on"),
              },
          }

          mime, _ = mimetypes.guess_type(str(vp))
          media = MediaFileUpload(str(vp), mimetype=mime or "video/mp4", chunksize=1024*1024, resumable=True)
          req = yt.videos().insert(part="snippet,status", body=body, media_body=media)

          resp = None; last=-1; start=time.monotonic()
          while resp is None:
              status, resp = req.next_chunk()
              if status and hasattr(status, "progress"):
                  try:
                      pct = int(float(status.progress())*100)
                      if pct != last:
                          print(f"[upload] {pct}%"); last=pct
                  except Exception:
                      pass
              if time.monotonic()-start > 1800:
                  raise RuntimeError("Upload timed out (1800s)")
          dump_json("out/youtube_response.json", resp or {})
          vid = (resp or {}).get("id")
          print("[done] https://youtu.be/"+vid if vid else "[done] (id yok)")
          PY

      - name: Upload artifact (${{ matrix.lang }})
        uses: actions/upload-artifact@v4
        with:
          name: output-story-${{ matrix.lang }}
          path: out/**
          if-no-files-found: warn
          retention-days: 7

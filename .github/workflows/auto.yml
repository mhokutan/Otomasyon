name: yt-auto-story

on:
  workflow_dispatch:
  schedule:
    - cron: "0 */8 * * *" # UTC; gÃ¼nde 3 kez

jobs:
  publish-story:
    runs-on: ubuntu-latest
    timeout-minutes: 60   # â¬…ï¸ 30 -> 60

    strategy:
      fail-fast: false
      matrix:
        include:
          - lang: en
            region: US
            title_prefix: "Mystery Story:"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Install system deps (ffmpeg & fonts)
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg fonts-dejavu-core

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install google-api-python-client google-auth google-auth-oauthlib

      - name: Preflight (keys)
        id: gates
        env:
          YT_CLIENT_ID: ${{ secrets.YT_CLIENT_ID }}
          YT_CLIENT_SECRET: ${{ secrets.YT_CLIENT_SECRET }}
          YT_REFRESH_TOKEN: ${{ secrets.YT_REFRESH_TOKEN }}
        run: |
          set -euo pipefail
          has_yt=false
          if [ -n "${YT_CLIENT_ID:-}" ] && [ -n "${YT_CLIENT_SECRET:-}" ] && [ -n "${YT_REFRESH_TOKEN:-}" ]; then
            has_yt=true
          else
            echo "::warning::YouTube secret'larÄ±ndan biri eksik; upload atlanacak"
          fi
          echo "has_yt=$has_yt" >> "$GITHUB_OUTPUT"

      - name: Build video (STORY â€¢ ${{ matrix.lang }})
        id: build
        env:
          THEME: "story"
          LANGUAGE: ${{ matrix.lang }}
          REGION: ${{ matrix.region }}
          VIDEO_TITLE_PREFIX: ${{ matrix.title_prefix }}

          # Seri sabitleme
          SERIES_LANG_KEY: "en"
          SERIES_NAME: "Mystery Files"
          SERIES_SEASON: "1"

          # OpenAI
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY != '' && secrets.OPENAI_API_KEY || vars.OPENAI_API_KEY }}
          OPENAI_BASE_URL: ${{ vars.OPENAI_BASE_URL != '' && vars.OPENAI_BASE_URL || 'https://api.openai.com/v1' }}
          OPENAI_MODEL_CHAT: ${{ vars.OPENAI_MODEL_CHAT != '' && vars.OPENAI_MODEL_CHAT || 'gpt-4o-mini' }}
          OPENAI_MODEL_TTS:  ${{ vars.OPENAI_MODEL_TTS  != '' && vars.OPENAI_MODEL_TTS  || 'gpt-4o-mini-tts' }}
          OPENAI_MAX_TOKENS: ${{ vars.OPENAI_MAX_TOKENS != '' && vars.OPENAI_MAX_TOKENS || '400' }}
          OPENAI_TEMPERATURE: ${{ vars.OPENAI_TEMPERATURE != '' && vars.OPENAI_TEMPERATURE || '0.7' }}

          # ðŸ”Š TTS
          TTS_VOICE: ${{ vars.TTS_VOICE != '' && vars.TTS_VOICE || 'alloy' }}
          TTS_ATEMPO: ${{ vars.TTS_ATEMPO != '' && vars.TTS_ATEMPO || '1.07' }}
          TTS_GAP_MS: ${{ vars.TTS_GAP_MS != '' && vars.TTS_GAP_MS || '150' }}   # â¬…ï¸ boÅŸluklarÄ± kÄ±salt
          TTS_BITRATE: ${{ vars.TTS_BITRATE != '' && vars.TTS_BITRATE || '128k' }}

          # ðŸŽ¬ Video (daha hÄ±zlÄ± render)
          BG_IMAGES_PER_SLIDE: ${{ vars.BG_IMAGES_PER_SLIDE != '' && vars.BG_IMAGES_PER_SLIDE || '2' }}  # â¬…ï¸ 4 -> 2
          FPS: ${{ vars.FPS != '' && vars.FPS || '30' }}                                                 # â¬…ï¸ 60 -> 30
          CRF: ${{ vars.CRF != '' && vars.CRF || '24' }}                                                 # â¬…ï¸ 22 -> 24
          ALLOW_NET_BG: ${{ vars.ALLOW_NET_BG != '' && vars.ALLOW_NET_BG || '0' }}
          NET_TIMEOUT: ${{ vars.NET_TIMEOUT != '' && vars.NET_TIMEOUT || '15' }}
          MAX_BG_SIZE_MB: ${{ vars.MAX_BG_SIZE_MB != '' && vars.MAX_BG_SIZE_MB || '6' }}
          FFMPEG_TIMEOUT: ${{ vars.FFMPEG_TIMEOUT != '' && vars.FFMPEG_TIMEOUT || '180' }}

          # Presenter/overlay
          BREAKING_ON: ${{ vars.BREAKING_ON != '' && vars.BREAKING_ON || '0' }}
          BREAKING_TEXT: ${{ vars.BREAKING_TEXT != '' && vars.BREAKING_TEXT || 'BREAKING' }}
          PRESENTER_URL: ${{ vars.PRESENTER_URL }}
          PRESENTER_POS: ${{ vars.PRESENTER_POS != '' && vars.PRESENTER_POS || 'top-right' }}
          PRESENTER_SIZE: ${{ vars.PRESENTER_SIZE != '' && vars.PRESENTER_SIZE || '220' }}  # â¬…ï¸ biraz kÃ¼Ã§Ã¼lttÃ¼k
          PRESENTER_INITIALS: ${{ vars.PRESENTER_INITIALS != '' && vars.PRESENTER_INITIALS || 'AI' }}

          HF_TOKEN: ${{ secrets.HF_TOKEN != '' && secrets.HF_TOKEN || vars.HF_TOKEN }}

          PYTHONIOENCODING: "utf-8"
          LANG: "en_US.UTF-8"
          PYTHONFAULTHANDLER: "1"
        run: |
          set -euo pipefail
          mkdir -p out
          echo "== RUN =="
          python -X dev -u -m src.main 2>&1 | tee "out/run_${{ matrix.lang }}.log" || true
          echo "== OUT =="
          ls -lah out || true

          latest="$(ls -t out/*.mp4 2>/dev/null | head -n1 || true)"
          if [ -z "$latest" ]; then
            echo "::error::HiÃ§ .mp4 Ã¼retilmemiÅŸ gÃ¶rÃ¼nÃ¼yor (out/*.mp4 bulunamadÄ±)"; exit 1
          fi

          echo "SeÃ§ilen video: $latest"
          # Ses var mÄ±?
          if ! ffprobe -v error -select_streams a -show_entries stream=codec_name -of csv=p=0 "$latest" | grep -q .; then
            echo "::error::Videoda audio stream yok. TTS baÅŸarÄ±sÄ±z olmuÅŸ olabilir. out/run_${{ matrix.lang }}.log dosyasÄ±nÄ± kontrol edin."
            exit 1
          fi

          echo "video_path=$latest" >> "$GITHUB_OUTPUT"

      - name: Read SEO metadata (from out/seo_meta.json)
        id: seo
        env:
          FALLBACK_TITLE: ${{ matrix.title_prefix }} Daily Auto Story
          FALLBACK_DESC: Lang=${{ matrix.lang }}, Region=${{ matrix.region }} â€¢ Auto upload
        run: |
          set -euo pipefail
          python - << 'PY'
          import os, json, pathlib
          p = pathlib.Path("out/seo_meta.json")
          title = os.environ.get("FALLBACK_TITLE","Auto Story")
          desc  = os.environ.get("FALLBACK_DESC","")
          tags  = "shorts,story,ai"
          if p.exists():
              try:
                  d = json.loads(p.read_text(encoding="utf-8"))
                  title = d.get("title") or title
                  desc  = d.get("description") or desc
                  tags  = d.get("tags") or tags
              except Exception as e:
                  print(f"::warning::seo_meta.json parse failed: {e}")
          go = os.environ["GITHUB_OUTPUT"]
          with open(go, "a", encoding="utf-8") as f:
              f.write(f"title<<EOF\n{title}\nEOF\n")
              f.write(f"description<<EOF\n{desc}\nEOF\n")
              f.write(f"tags_csv={tags}\n")
          PY

      - name: Auth smoke test (YouTube)
        if: ${{ steps.gates.outputs.has_yt == 'true' }}
        env:
          YT_CLIENT_ID: ${{ secrets.YT_CLIENT_ID }}
          YT_CLIENT_SECRET: ${{ secrets.YT_CLIENT_SECRET }}
          YT_REFRESH_TOKEN: ${{ secrets.YT_REFRESH_TOKEN }}
        run: |
          python - << 'PY'
          import os
          import google.auth.transport.requests
          from google.oauth2.credentials import Credentials
          creds = Credentials(
              None,
              refresh_token=os.environ["YT_REFRESH_TOKEN"],
              client_id=os.environ["YT_CLIENT_ID"],
              client_secret=os.environ["YT_CLIENT_SECRET"],
              token_uri="https://oauth2.googleapis.com/token",
          )
          creds.refresh(google.auth.transport.requests.Request())
          print("Refresh OK")
          PY

      - name: Upload to YouTube (${{ matrix.lang }})
        if: ${{ steps.gates.outputs.has_yt == 'true' }}
        env:
          VIDEO_PATH: ${{ steps.build.outputs.video_path }}
          SEO_TITLE: ${{ steps.seo.outputs.title }}
          SEO_DESC: ${{ steps.seo.outputs.description }}
          SEO_TAGS_CSV: ${{ steps.seo.outputs.tags_csv }}
          FALLBACK_TITLE: ${{ matrix.title_prefix }} Daily Auto Story
          FALLBACK_DESC: Lang=${{ matrix.lang }}, Region=${{ matrix.region }} â€¢ Auto upload
          YT_PRIVACY: "public"
          YT_MADE_FOR_KIDS: "false"
          YT_CLIENT_ID: ${{ secrets.YT_CLIENT_ID }}
          YT_CLIENT_SECRET: ${{ secrets.YT_CLIENT_SECRET }}
          YT_REFRESH_TOKEN: ${{ secrets.YT_REFRESH_TOKEN }}
          YT_DEBUG: "1"
        run: |
          set -euo pipefail
          TITLE="${SEO_TITLE:-$FALLBACK_TITLE}"
          DESC="${SEO_DESC:-$FALLBACK_DESC}"
          TAGS="${SEO_TAGS_CSV:-shorts,story,ai}"

          echo "YÃ¼klenecek dosya: $VIDEO_PATH"
          echo "BaÅŸlÄ±k: $TITLE"
          echo "AÃ§Ä±klama (ilk 160): ${DESC:0:160}..."
          echo "Etiketler: $TAGS"

          python - << 'PY'
          import os, json, mimetypes, pathlib, time
          from typing import Any
          from googleapiclient.discovery import build
          from googleapiclient.http import MediaFileUpload
          from google.auth.transport.requests import Request
          from google.oauth2.credentials import Credentials

          def dump_json(path: str, obj: Any) -> None:
              os.makedirs("out", exist_ok=True)
              with open(path, "w", encoding="utf-8") as f:
                  json.dump(obj, f, ensure_ascii=False, indent=2)

          def creds() -> Credentials:
              c = Credentials(None,
                  refresh_token=os.environ["YT_REFRESH_TOKEN"],
                  client_id=os.environ["YT_CLIENT_ID"],
                  client_secret=os.environ["YT_CLIENT_SECRET"],
                  token_uri="https://oauth2.googleapis.com/token")
              c.refresh(Request())
              return c

          vp = pathlib.Path(os.environ["VIDEO_PATH"])
          if not vp.exists() or vp.stat().st_size <= 0:
              raise SystemExit("Video bulunamadÄ±/boÅŸ: " + str(vp))

          tags = [t.strip() for t in os.environ.get("TAGS","").split(",") if t.strip()]
          if not tags:
              tags = [t.strip() for t in os.environ.get("SEO_TAGS_CSV","").split(",") if t.strip()]

          yt = build("youtube","v3",credentials=creds(), cache_discovery=False)
          body = {
            "snippet": {
              "title": os.environ.get("TITLE","Auto Story")[:95],
              "description": os.environ.get("DESC","")[:4900],
              "categoryId": "22",
              **({"tags": tags} if tags else {})
            },
            "status": {
              "privacyStatus": os.environ.get("YT_PRIVACY","public"),
              "selfDeclaredMadeForKids": os.environ.get("YT_MADE_FOR_KIDS","false").lower() in ("1","true","yes","on"),
            }
          }
          mime,_ = mimetypes.guess_type(str(vp))
          media = MediaFileUpload(str(vp), mimetype=mime or "video/mp4", chunksize=1024*1024, resumable=True)
          req = yt.videos().insert(part="snippet,status", body=body, media_body=media)

          resp=None; last=-1; start=time.monotonic()
          while resp is None:
              status, resp = req.next_chunk()
              if status and hasattr(status,"progress"):
                  try:
                      pct=int(float(status.progress())*100)
                      if pct!=last: print(f"[upload] {pct}%"); last=pct
                  except Exception: pass
              if time.monotonic()-start>1800:
                  raise RuntimeError("Upload timed out (1800s)")
          dump_json("out/youtube_response.json", resp or {})
          vid=(resp or {}).get("id")
          print("[done] https://youtu.be/"+vid if vid else "[done] (id yok)")
          PY

      - name: Upload artifact (${{ matrix.lang }})
        uses: actions/upload-artifact@v4
        with:
          name: output-story-${{ matrix.lang }}
          path: out/**
          if-no-files-found: warn
          retention-days: 7
